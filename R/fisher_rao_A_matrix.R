#' Get Fisher-Rao A Matrix
#'
#' Computes the A matrix used in Fisher-Rao geodesic calculations. 
#' The A matrix is the logarithm of T'T where T is the optimized transformation
#' matrix from Eriksen (1987). This matrix satisfies the geodesic equations
#' from Skovgaard (1984) and is used to generate the geodesic path via Λ(t) = exp(t·A).
#'
#' @param mu1 Mean vector of the first distribution
#' @param Sigma1 Covariance matrix of the first distribution
#' @param mu2 Mean vector of the second distribution
#' @param Sigma2 Covariance matrix of the second distribution
#' @param method Optimization method (default: "BFGS")
#' @param control Control parameters for optim()
#'
#' @return A matrix of size (2p+1) × (2p+1) where p = length(mu1). 
#'   Returns NULL if computation fails or matrices are ill-conditioned.
#'   
#'   The block structure of A is:
#'   \deqn{A = \begin{bmatrix} A_{11} & a_{12} & 0 \\ a_{21} & 0 & -a_{12}^T \\ 0 & -a_{12} & -A_{11} \end{bmatrix}}
#'   where \eqn{A_{11}} is pp and \eqn{a_{12}} is p1.
#'
#' @details
#' The A matrix is computed by:
#' 1. Transforming the distributions to canonical coordinates relative to (0, I)
#' 2. Optimizing the upper triangular components y to minimize tr(C(y)²)
#' 3. Constructing T from the optimal y
#' 4. Computing A = log(T'T)
#' 
#' The geodesic path is then generated by Λ(t) = exp(t·A) for t ∈ [0,1].
#'
#' @examples
#' # Bivariate example
#' mu1 <- c(0, 0)
#' Sigma1 <- diag(2)
#' mu2 <- c(1, 1)
#' Sigma2 <- matrix(c(2, 0.5, 0.5, 1), 2, 2)
#' 
#' A <- fisher_rao_A_matrix(mu1, Sigma1, mu2, Sigma2)
#' print(A)
#' 
#' # The distance can be computed from A
#' distance <- sqrt(sum(A^2) / 2)
#' print(distance)
#'
#' @references
#' Skovgaard, L. T. (1984). A Riemannian geometry of the multivariate
#' normal model. Scandinavian Journal of Statistics, 11(4), 211-223.
#'
#' Eriksen, P. S. (1987). Geodesics connected with the Fisher metric on
#' the multivariate normal manifold. Proceedings of the GST Workshop.
#'
#' For detailed theory and implementation, see the included paper:
#' \code{system.file("fisher_rao_geodesic.pdf", package = "mvndist")}
#'
#' @importFrom expm logm
#' @export
fisher_rao_A_matrix <- function(mu1, Sigma1, mu2, Sigma2, 
                                 method = "BFGS", control = list()) {
  p <- length(mu1)
  
  # Transform to canonical parameters relative to (0, I)
  U <- chol(solve(Sigma1))
  U_inv <- solve(U)
  
  mu_transformed <- U %*% (mu2 - mu1)
  Sigma_transformed <- U %*% Sigma2 %*% t(U)
  
  De <- solve(Sigma_transformed)
  
  # Check for ill-conditioned De matrix (crucial for A matrix computation)
  cond_De <- kappa(De)
  
  if (cond_De > 1e10) {
    warning(paste("Ill-conditioned De matrix detected (kappa =", round(cond_De, 2), ").",
                  "A matrix may be inaccurate."))
    return(NULL)
  }
  de <- De %*% mu_transformed
  
  # Univariate case - compute A directly
  if (p == 1) {
    de_scalar <- as.numeric(de)
    De_scalar <- as.numeric(De)
    
    # For univariate case, A is simpler
    # We construct a 3×3 matrix following the same structure
    A <- matrix(0, 3, 3)
    
    # Diagonal blocks
    A[1, 1] <- 0.5 * log(De_scalar)
    A[3, 3] <- -0.5 * log(De_scalar)
    
    # Off-diagonal
    A[1, 2] <- de_scalar / (2 * sqrt(De_scalar))
    A[2, 3] <- -de_scalar / (2 * sqrt(De_scalar))
    
    return(A)
  }
  
  # Multivariate case - optimize to find geodesic
  # Diagonalize De via eigendecomposition
  eigen_De <- eigen(De)
  De_diag <- diag(eigen_De$values)
  V <- eigen_De$vectors
  de_rotated <- t(V) %*% de
  
  # Transform to d and D
  D <- sqrt(diag(De_diag))
  d <- de_rotated / D
  
  # Optimize y (upper triangular part of Z)
  n_y <- p*(p-1)/2
  y0 <- rnorm(n_y, mean = 0, sd = 0.01)
  
  # Try optimization with multiple restarts
  best_result <- list(value = Inf)
  
  for (attempt in 1:3) {
    result <- optim(
      par = if(attempt == 1) y0 else rnorm(n_y, sd = 0.05),
      fn = objective_f,
      gr = gradient_f,
      d = d,
      D = D,
      method = method,
      control = control
    )
    
    if (result$value < best_result$value) {
      best_result <- result
    }
    
    # Break early if converged well
    if (result$value < 1e-6) break
  }
  
  result <- best_result
  
  # Check convergence
  if (result$value > 1e-4) {
    warning(paste("Optimization may not have converged. f(y) =", 
                  round(result$value, 8)))
  }
  
  # Compute A matrix from optimized T
  T_mat <- construct_T(result$par, d, D)
  TtT <- t(T_mat) %*% T_mat
  A <- expm::logm(TtT)
  
  # Add dimension labels
  dimnames(A) <- list(
    c(paste0("eta_", 1:p), "eta_0", paste0("theta_", 1:p)),
    c(paste0("eta_", 1:p), "eta_0", paste0("theta_", 1:p))
  )
  
  return(A)
}
